<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>SLC: Structure-Logic-Computation Theorem Implementation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="slc.html" class="tocviewselflink" data-pltdoc="x">SLC:<span class="mywbr"> &nbsp;</span> Structure-<wbr></wbr>Logic-<wbr></wbr>Computation Theorem Implementation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="slc.html#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="slc.html#%28part._.Quick_.Start%29" class="tocviewlink" data-pltdoc="x">Quick Start</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="slc.html#%28part._.Theoretical_.Background%29" class="tocviewlink" data-pltdoc="x">Theoretical Background</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="slc.html#%28part._.Architecture_.Overview%29" class="tocviewlink" data-pltdoc="x">Architecture Overview</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="slc.html#%28part._.The_.S.L.C_.Implementation%29" class="tocviewlink" data-pltdoc="x">The SLC Implementation</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="slc.html#%28part._.Interactive_.Commands%29" class="tocviewlink" data-pltdoc="x">Interactive Commands</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="slc.html#%28part._.Examples_and_.Applications%29" class="tocviewlink" data-pltdoc="x">Examples and Applications</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="slc.html#%28part._.Applications%29" class="tocviewlink" data-pltdoc="x">Applications</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="slc.html#%28part._.Performance_and_.Optimization%29" class="tocviewlink" data-pltdoc="x">Performance and Optimization</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="slc.html#%28part._.Future_.Enhancements%29" class="tocviewlink" data-pltdoc="x">Future Enhancements</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="slc.html#%28part._.Installation_.Guide%29" class="tocviewlink" data-pltdoc="x">Installation Guide</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="slc.html#%28part._.Implementation_.Reference%29" class="tocviewlink" data-pltdoc="x">Implementation Reference</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="slc.html#%28part._.Research_.Context%29" class="tocviewlink" data-pltdoc="x">Research Context</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.S.L.C__.Structure-.Logic-.Computation_.Theorem_.Implementation%29" class="tocsubseclink" data-pltdoc="x">SLC:<span class="mywbr"> &nbsp;</span> Structure-<wbr></wbr>Logic-<wbr></wbr>Computation Theorem Implementation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Why_.C.H.L_.Alone_.Is_.Not_.Enough%29" class="tocsubseclink" data-pltdoc="x">Why CHL Alone Is Not Enough</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.S.L.C_.Triangle%29" class="tocsubseclink" data-pltdoc="x">The SLC Triangle</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Quick_.Start%29" class="tocsubseclink" data-pltdoc="x">Quick Start</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Installation%29" class="tocsubseclink" data-pltdoc="x">Installation</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Interactive_.Example%29" class="tocsubseclink" data-pltdoc="x">Interactive Example</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Theoretical_.Background%29" class="tocsubseclink" data-pltdoc="x">Theoretical Background</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Lawvere_.Theories%29" class="tocsubseclink" data-pltdoc="x">Lawvere Theories</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.The_.Logic_.Category_.L_.T%29" class="tocsubseclink" data-pltdoc="x">The Logic Category L_<span class="mywbr"> &nbsp;</span>T</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.The_.Computation_.Category_.C_.T%29" class="tocsubseclink" data-pltdoc="x">The Computation Category C_<span class="mywbr"> &nbsp;</span>T</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Architecture_.Overview%29" class="tocsubseclink" data-pltdoc="x">Architecture Overview</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Core_.Theory_.Modules%29" class="tocsubseclink" data-pltdoc="x">Core Theory Modules</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.S.L.C_.Core%29" class="tocsubseclink" data-pltdoc="x">SLC Core</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._.Implementation_.Support%29" class="tocsubseclink" data-pltdoc="x">Implementation Support</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="#%28part._.User_.Interface%29" class="tocsubseclink" data-pltdoc="x">User Interface</a></td></tr><tr><td><span class="tocsublinknumber">4.5<tt>&nbsp;</tt></span><a href="#%28part._.Example_.Theories%29" class="tocsubseclink" data-pltdoc="x">Example Theories</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.The_.S.L.C_.Implementation%29" class="tocsubseclink" data-pltdoc="x">The SLC Implementation</a></td></tr><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Core_.S.L.C_.Function%29" class="tocsubseclink" data-pltdoc="x">Core SLC Function</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Search_.Algorithms%29" class="tocsubseclink" data-pltdoc="x">Search Algorithms</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Interactive_.Commands%29" class="tocsubseclink" data-pltdoc="x">Interactive Commands</a></td></tr><tr><td><span class="tocsublinknumber">6.1<tt>&nbsp;</tt></span><a href="#%28part._.Theory_.Management%29" class="tocsubseclink" data-pltdoc="x">Theory Management</a></td></tr><tr><td><span class="tocsublinknumber">6.2<tt>&nbsp;</tt></span><a href="#%28part._.Proof_and_.Computation%29" class="tocsubseclink" data-pltdoc="x">Proof and Computation</a></td></tr><tr><td><span class="tocsublinknumber">6.3<tt>&nbsp;</tt></span><a href="#%28part._.Simulation%29" class="tocsubseclink" data-pltdoc="x">Simulation</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Examples_and_.Applications%29" class="tocsubseclink" data-pltdoc="x">Examples and Applications</a></td></tr><tr><td><span class="tocsublinknumber">7.1<tt>&nbsp;</tt></span><a href="#%28part._.Monoid_.Properties%29" class="tocsubseclink" data-pltdoc="x">Monoid Properties</a></td></tr><tr><td><span class="tocsublinknumber">7.2<tt>&nbsp;</tt></span><a href="#%28part._.Group_.Inverse_.Laws%29" class="tocsubseclink" data-pltdoc="x">Group Inverse Laws</a></td></tr><tr><td><span class="tocsublinknumber">7.3<tt>&nbsp;</tt></span><a href="#%28part._.Ring_.Distributivity%29" class="tocsubseclink" data-pltdoc="x">Ring Distributivity</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Applications%29" class="tocsubseclink" data-pltdoc="x">Applications</a></td></tr><tr><td><span class="tocsublinknumber">8.1<tt>&nbsp;</tt></span><a href="#%28part._.Security_.Analysis%29" class="tocsubseclink" data-pltdoc="x">Security Analysis</a></td></tr><tr><td><span class="tocsublinknumber">8.2<tt>&nbsp;</tt></span><a href="#%28part._.Language_.Design%29" class="tocsubseclink" data-pltdoc="x">Language Design</a></td></tr><tr><td><span class="tocsublinknumber">8.3<tt>&nbsp;</tt></span><a href="#%28part._.Formal_.Verification%29" class="tocsubseclink" data-pltdoc="x">Formal Verification</a></td></tr><tr><td><span class="tocsublinknumber">8.4<tt>&nbsp;</tt></span><a href="#%28part._.Automated_.Reasoning%29" class="tocsubseclink" data-pltdoc="x">Automated Reasoning</a></td></tr><tr><td><span class="tocsublinknumber">9<tt>&nbsp;</tt></span><a href="#%28part._.Performance_and_.Optimization%29" class="tocsubseclink" data-pltdoc="x">Performance and Optimization</a></td></tr><tr><td><span class="tocsublinknumber">10<tt>&nbsp;</tt></span><a href="#%28part._.Future_.Enhancements%29" class="tocsubseclink" data-pltdoc="x">Future Enhancements</a></td></tr><tr><td><span class="tocsublinknumber">10.1<tt>&nbsp;</tt></span><a href="#%28part._.Complete_.L_.T_~e2~86~94_.C_.T_.Bridge%29" class="tocsubseclink" data-pltdoc="x">Complete L_<span class="mywbr"> &nbsp;</span>T ↔ C_<span class="mywbr"> &nbsp;</span>T Bridge</a></td></tr><tr><td><span class="tocsublinknumber">10.2<tt>&nbsp;</tt></span><a href="#%28part._.Knuth-.Bendix_.Completion%29" class="tocsubseclink" data-pltdoc="x">Knuth-<wbr></wbr>Bendix Completion</a></td></tr><tr><td><span class="tocsublinknumber">11<tt>&nbsp;</tt></span><a href="#%28part._.Installation_.Guide%29" class="tocsubseclink" data-pltdoc="x">Installation Guide</a></td></tr><tr><td><span class="tocsublinknumber">11.1<tt>&nbsp;</tt></span><a href="#%28part._.Install_.Racket%29" class="tocsubseclink" data-pltdoc="x">Install Racket</a></td></tr><tr><td><span class="tocsublinknumber">11.2<tt>&nbsp;</tt></span><a href="#%28part._.Setup_.S.L.C%29" class="tocsubseclink" data-pltdoc="x">Setup SLC</a></td></tr><tr><td><span class="tocsublinknumber">11.3<tt>&nbsp;</tt></span><a href="#%28part._.Quick_.Test%29" class="tocsubseclink" data-pltdoc="x">Quick Test</a></td></tr><tr><td><span class="tocsublinknumber">11.4<tt>&nbsp;</tt></span><a href="#%28part._.Troubleshooting%29" class="tocsubseclink" data-pltdoc="x">Troubleshooting</a></td></tr><tr><td><span class="tocsublinknumber">12<tt>&nbsp;</tt></span><a href="#%28part._.Implementation_.Reference%29" class="tocsubseclink" data-pltdoc="x">Implementation Reference</a></td></tr><tr><td><span class="tocsublinknumber">12.1<tt>&nbsp;</tt></span><a href="#%28part._.Core_.Interface%29" class="tocsubseclink" data-pltdoc="x">Core Interface</a></td></tr><tr><td><span class="tocsublinknumber">12.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Unified_.Interface%29" class="tocsubseclink" data-pltdoc="x">Unified Interface</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fcore..rkt%29._slc-prove%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">slc-<wbr></wbr>prove</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fcore..rkt%29._slc-simulate%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">slc-<wbr></wbr>simulate</span></a></td></tr><tr><td><span class="tocsublinknumber">12.2<tt>&nbsp;</tt></span><a href="#%28part._.Terms_and_.Theories%29" class="tocsubseclink" data-pltdoc="x">Terms and Theories</a></td></tr><tr><td><span class="tocsublinknumber">12.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Term_.Representation%29" class="tocsubseclink" data-pltdoc="x">Term Representation</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term-var%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term-<wbr></wbr>var</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term-const%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term-<wbr></wbr>const</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term-op%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term-<wbr></wbr>op</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term~3f%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term?</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term-equal~3f%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term-<wbr></wbr>equal?</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._free-vars%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">free-<wbr></wbr>vars</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._substitute%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">substitute</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._rename-vars%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">rename-<wbr></wbr>vars</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fterms..rkt%29._term-size%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">term-<wbr></wbr>size</span></a></td></tr><tr><td><span class="tocsublinknumber">12.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Lawvere_.Theories%29" class="tocsubseclink" data-pltdoc="x">Lawvere Theories</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheories..rkt%29._lawvere-theory%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">lawvere-<wbr></wbr>theory</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheories..rkt%29._make-theory%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">make-<wbr></wbr>theory</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheories..rkt%29._theory-axioms%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">theory-<wbr></wbr>axioms</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheories..rkt%29._theory-name%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">theory-<wbr></wbr>name</span></a></td></tr><tr><td><span class="tocsublinknumber">12.3<tt>&nbsp;</tt></span><a href="#%28part._.Categories%29" class="tocsubseclink" data-pltdoc="x">Categories</a></td></tr><tr><td><span class="tocsublinknumber">12.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Logic_.Category_.L_.T%29" class="tocsubseclink" data-pltdoc="x">Logic Category L_<span class="mywbr"> &nbsp;</span>T</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Flt..rkt%29._lt-prove-equality%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">lt-<wbr></wbr>prove-<wbr></wbr>equality</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Flt..rkt%29._lt-build-proof%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">lt-<wbr></wbr>build-<wbr></wbr>proof</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Flt..rkt%29._proof-object%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">proof-<wbr></wbr>object</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Flt..rkt%29._proof-step%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">proof-<wbr></wbr>step</span></a></td></tr><tr><td><span class="tocsublinknumber">12.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Computation_.Category_.C_.T%29" class="tocsubseclink" data-pltdoc="x">Computation Category C_<span class="mywbr"> &nbsp;</span>T</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fct..rkt%29._ct-find-path%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">ct-<wbr></wbr>find-<wbr></wbr>path</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fct..rkt%29._one-step-rewrites%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">one-<wbr></wbr>step-<wbr></wbr>rewrites</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fct..rkt%29._normalize-term%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">normalize-<wbr></wbr>term</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fct..rkt%29._ct-reachable-terms%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">ct-<wbr></wbr>reachable-<wbr></wbr>terms</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fct..rkt%29._smart-search%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">smart-<wbr></wbr>search</span></a></td></tr><tr><td><span class="tocsublinknumber">12.4<tt>&nbsp;</tt></span><a href="#%28part._.S.L.C_.Integration%29" class="tocsubseclink" data-pltdoc="x">SLC Integration</a></td></tr><tr><td><span class="tocsublinknumber">12.4.1<tt>&nbsp;</tt></span><a href="#%28part._.Core_.S.L.C_.Implementation%29" class="tocsubseclink" data-pltdoc="x">Core SLC Implementation</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fslc-simulator..rkt%29._prover%2Bsimulator%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">prover+<span class="mywbr"> &nbsp;</span>simulator</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fslc-simulator..rkt%29._simulate-rewrites%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">simulate-<wbr></wbr>rewrites</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fslc-simulator..rkt%29._reachable-terms-by-depth%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">reachable-<wbr></wbr>terms-<wbr></wbr>by-<wbr></wbr>depth</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fslc-simulator..rkt%29._slc-result%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">slc-<wbr></wbr>result</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fslc-simulator..rkt%29._simulation-result%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">simulation-<wbr></wbr>result</span></a></td></tr><tr><td><span class="tocsublinknumber">12.5<tt>&nbsp;</tt></span><a href="#%28part._.Theory_.Analysis%29" class="tocsubseclink" data-pltdoc="x">Theory Analysis</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheory-analysis..rkt%29._analyze-theory%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">analyze-<wbr></wbr>theory</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheory-analysis..rkt%29._check-confluence%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">check-<wbr></wbr>confluence</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheory-analysis..rkt%29._estimate-complexity%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">estimate-<wbr></wbr>complexity</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheory-analysis..rkt%29._suggest-optimizations%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">suggest-<wbr></wbr>optimizations</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ftheory-analysis..rkt%29._theory-analysis%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">theory-<wbr></wbr>analysis</span></a></td></tr><tr><td><span class="tocsublinknumber">12.6<tt>&nbsp;</tt></span><a href="#%28part._.Parsing_and_.Formatting%29" class="tocsubseclink" data-pltdoc="x">Parsing and Formatting</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fparser..rkt%29._parse-term%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">parse-<wbr></wbr>term</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fparser..rkt%29._parse-equation%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">parse-<wbr></wbr>equation</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fparser..rkt%29._format-term%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">format-<wbr></wbr>term</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fparser..rkt%29._format-equation%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">format-<wbr></wbr>equation</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fparser..rkt%29._parse-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">parse-<wbr></wbr>error</span></a></td></tr><tr><td><span class="tocsublinknumber">12.7<tt>&nbsp;</tt></span><a href="#%28part._.Proof_.Objects%29" class="tocsubseclink" data-pltdoc="x">Proof Objects</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fproofs..rkt%29._make-proof%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">make-<wbr></wbr>proof</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fproofs..rkt%29._proof-valid~3f%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">proof-<wbr></wbr>valid?</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fproofs..rkt%29._proof-length%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">proof-<wbr></wbr>length</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fproofs..rkt%29._compose-proofs%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">compose-<wbr></wbr>proofs</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fproofs..rkt%29._format-proof%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">format-<wbr></wbr>proof</span></a></td></tr><tr><td><span class="tocsublinknumber">12.8<tt>&nbsp;</tt></span><a href="#%28part._.Performance_and_.Benchmarking%29" class="tocsubseclink" data-pltdoc="x">Performance and Benchmarking</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._benchmark-methods%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">benchmark-<wbr></wbr>methods</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._performance-profile%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">performance-<wbr></wbr>profile</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._clear-all-caches%21%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">clear-<wbr></wbr>all-<wbr></wbr>caches!</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._get-cache-statistics%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">get-<wbr></wbr>cache-<wbr></wbr>statistics</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._benchmark-result%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">benchmark-<wbr></wbr>result</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fperformance-demo..rkt%29._method-result%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">method-<wbr></wbr>result</span></a></td></tr><tr><td><span class="tocsublinknumber">12.9<tt>&nbsp;</tt></span><a href="#%28part._.Error_.Handling%29" class="tocsubseclink" data-pltdoc="x">Error Handling</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._slc-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">slc-<wbr></wbr>error</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._parse-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">parse-<wbr></wbr>error</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._theory-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">theory-<wbr></wbr>error</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._proof-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">proof-<wbr></wbr>error</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._slc-error~3f%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">slc-<wbr></wbr>error?</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Ferrors..rkt%29._format-error%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">format-<wbr></wbr>error</span></a></td></tr><tr><td><span class="tocsublinknumber">12.10<tt>&nbsp;</tt></span><a href="#%28part._.Example_.Theories%29" class="tocsubseclink" data-pltdoc="x">Example Theories</a></td></tr><tr><td><span class="tocsublinknumber">12.10.1<tt>&nbsp;</tt></span><a href="#%28part._.Monoids%29" class="tocsubseclink" data-pltdoc="x">Monoids</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fmonoid..rkt%29._.T_.Monoid%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">T_<span class="mywbr"> &nbsp;</span>Monoid</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fmonoid..rkt%29._mvar%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">mvar</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fmonoid..rkt%29._me%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">me</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fmonoid..rkt%29._m%2A%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">m*</span></a></td></tr><tr><td><span class="tocsublinknumber">12.10.2<tt>&nbsp;</tt></span><a href="#%28part._.Groups%29" class="tocsubseclink" data-pltdoc="x">Groups</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fgroup..rkt%29._.T_.Group%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">T_<span class="mywbr"> &nbsp;</span>Group</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fgroup..rkt%29._ginv%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">ginv</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fgroup..rkt%29._ge%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">ge</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fgroup..rkt%29._g%2A%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">g*</span></a></td></tr><tr><td><span class="tocsublinknumber">12.10.3<tt>&nbsp;</tt></span><a href="#%28part._.Rings%29" class="tocsubseclink" data-pltdoc="x">Rings</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._.T_.Ring%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">T_<span class="mywbr"> &nbsp;</span>Ring</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._r%2B%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">r+</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._r%2A%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">r*</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._rzero%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">rzero</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._rone%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">rone</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Fexamples%2Fring..rkt%29._rneg%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">rneg</span></a></td></tr><tr><td><span class="tocsublinknumber">12.11<tt>&nbsp;</tt></span><a href="#%28part._.Interactive_.Interface%29" class="tocsubseclink" data-pltdoc="x">Interactive Interface</a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Finteractive..rkt%29._start-slc-repl%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">start-<wbr></wbr>slc-<wbr></wbr>repl</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Finteractive..rkt%29._process-command%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">process-<wbr></wbr>command</span></a></td></tr><tr><td><a href="#%28def._%28%28lib._slc%2Finteractive..rkt%29._repl-state%29%29" class="tocsubnonseclink" data-pltdoc="x"><span class="RktSym">repl-<wbr></wbr>state</span></a></td></tr><tr><td><span class="tocsublinknumber">13<tt>&nbsp;</tt></span><a href="#%28part._.Research_.Context%29" class="tocsubseclink" data-pltdoc="x">Research Context</a></td></tr><tr><td><span class="tocsublinknumber">13.1<tt>&nbsp;</tt></span><a href="#%28part._.Related_.Work%29" class="tocsubseclink" data-pltdoc="x">Related Work</a></td></tr><tr><td><span class="tocsublinknumber">13.2<tt>&nbsp;</tt></span><a href="#%28part._.Citation%29" class="tocsubseclink" data-pltdoc="x">Citation</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.17</span></div><h2 class="heading"><a name="(part._.S.L.C__.Structure-.Logic-.Computation_.Theorem_.Implementation)"></a><a name="(mod-path._slc)"></a>SLC: Structure-Logic-Computation Theorem Implementation<span class="button-group"><a href="#(part._.S.L.C__.Structure-.Logic-.Computation_.Theorem_.Implementation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Pedro Cavalcante</p></span></div><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>This document describes the Racket implementation of the Structure-Logic-Computation (SLC) theorem,
which extends the classical Curry-Howard-Lambek correspondence. The SLC theorem shows that
any Lawvere theory <span style="font-style: italic">T</span> canonically generates both a logic category <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> and
a computation category <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span>, with deep structural relationships between them.</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Introduction%29" class="toptoclink" data-pltdoc="x">1<span class="hspace">&nbsp;</span>Introduction</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Why_.C.H.L_.Alone_.Is_.Not_.Enough%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Why CHL Alone Is Not Enough</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.The_.S.L.C_.Triangle%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>The SLC Triangle</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Quick_.Start%29" class="toptoclink" data-pltdoc="x">2<span class="hspace">&nbsp;</span>Quick Start</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Installation%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Installation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Interactive_.Example%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Interactive Example</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Theoretical_.Background%29" class="toptoclink" data-pltdoc="x">3<span class="hspace">&nbsp;</span>Theoretical Background</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Lawvere_.Theories%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>Lawvere Theories</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.The_.Logic_.Category_.L_.T%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>The Logic Category L_T</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.The_.Computation_.Category_.C_.T%29" class="toclink" data-pltdoc="x">3.3<span class="hspace">&nbsp;</span>The Computation Category C_T</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Architecture_.Overview%29" class="toptoclink" data-pltdoc="x">4<span class="hspace">&nbsp;</span>Architecture Overview</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Core_.Theory_.Modules%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>Core Theory Modules</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.S.L.C_.Core%29" class="toclink" data-pltdoc="x">4.2<span class="hspace">&nbsp;</span>SLC Core</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Implementation_.Support%29" class="toclink" data-pltdoc="x">4.3<span class="hspace">&nbsp;</span>Implementation Support</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.User_.Interface%29" class="toclink" data-pltdoc="x">4.4<span class="hspace">&nbsp;</span>User Interface</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Example_.Theories%29" class="toclink" data-pltdoc="x">4.5<span class="hspace">&nbsp;</span>Example Theories</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.The_.S.L.C_.Implementation%29" class="toptoclink" data-pltdoc="x">5<span class="hspace">&nbsp;</span>The SLC Implementation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Core_.S.L.C_.Function%29" class="toclink" data-pltdoc="x">5.1<span class="hspace">&nbsp;</span>Core SLC Function</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Search_.Algorithms%29" class="toclink" data-pltdoc="x">5.2<span class="hspace">&nbsp;</span>Search Algorithms</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Interactive_.Commands%29" class="toptoclink" data-pltdoc="x">6<span class="hspace">&nbsp;</span>Interactive Commands</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Theory_.Management%29" class="toclink" data-pltdoc="x">6.1<span class="hspace">&nbsp;</span>Theory Management</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Proof_and_.Computation%29" class="toclink" data-pltdoc="x">6.2<span class="hspace">&nbsp;</span>Proof and Computation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Simulation%29" class="toclink" data-pltdoc="x">6.3<span class="hspace">&nbsp;</span>Simulation</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Examples_and_.Applications%29" class="toptoclink" data-pltdoc="x">7<span class="hspace">&nbsp;</span>Examples and Applications</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Monoid_.Properties%29" class="toclink" data-pltdoc="x">7.1<span class="hspace">&nbsp;</span>Monoid Properties</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Group_.Inverse_.Laws%29" class="toclink" data-pltdoc="x">7.2<span class="hspace">&nbsp;</span>Group Inverse Laws</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Ring_.Distributivity%29" class="toclink" data-pltdoc="x">7.3<span class="hspace">&nbsp;</span>Ring Distributivity</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Applications%29" class="toptoclink" data-pltdoc="x">8<span class="hspace">&nbsp;</span>Applications</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Security_.Analysis%29" class="toclink" data-pltdoc="x">8.1<span class="hspace">&nbsp;</span>Security Analysis</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Language_.Design%29" class="toclink" data-pltdoc="x">8.2<span class="hspace">&nbsp;</span>Language Design</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Formal_.Verification%29" class="toclink" data-pltdoc="x">8.3<span class="hspace">&nbsp;</span>Formal Verification</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Automated_.Reasoning%29" class="toclink" data-pltdoc="x">8.4<span class="hspace">&nbsp;</span>Automated Reasoning</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Performance_and_.Optimization%29" class="toptoclink" data-pltdoc="x">9<span class="hspace">&nbsp;</span>Performance and Optimization</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Future_.Enhancements%29" class="toptoclink" data-pltdoc="x">10<span class="hspace">&nbsp;</span>Future Enhancements</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Complete_.L_.T_~e2~86~94_.C_.T_.Bridge%29" class="toclink" data-pltdoc="x">10.1<span class="hspace">&nbsp;</span>Complete L_T &#8596; C_T Bridge</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Knuth-.Bendix_.Completion%29" class="toclink" data-pltdoc="x">10.2<span class="hspace">&nbsp;</span>Knuth-Bendix Completion</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Installation_.Guide%29" class="toptoclink" data-pltdoc="x">11<span class="hspace">&nbsp;</span>Installation Guide</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Install_.Racket%29" class="toclink" data-pltdoc="x">11.1<span class="hspace">&nbsp;</span>Install Racket</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Setup_.S.L.C%29" class="toclink" data-pltdoc="x">11.2<span class="hspace">&nbsp;</span>Setup SLC</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Quick_.Test%29" class="toclink" data-pltdoc="x">11.3<span class="hspace">&nbsp;</span>Quick Test</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Troubleshooting%29" class="toclink" data-pltdoc="x">11.4<span class="hspace">&nbsp;</span>Troubleshooting</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Implementation_.Reference%29" class="toptoclink" data-pltdoc="x">12<span class="hspace">&nbsp;</span>Implementation Reference</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Core_.Interface%29" class="toclink" data-pltdoc="x">12.1<span class="hspace">&nbsp;</span>Core Interface</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Unified_.Interface%29" class="toclink" data-pltdoc="x">12.1.1<span class="hspace">&nbsp;</span>Unified Interface</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Terms_and_.Theories%29" class="toclink" data-pltdoc="x">12.2<span class="hspace">&nbsp;</span>Terms and Theories</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Term_.Representation%29" class="toclink" data-pltdoc="x">12.2.1<span class="hspace">&nbsp;</span>Term Representation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Lawvere_.Theories%29" class="toclink" data-pltdoc="x">12.2.2<span class="hspace">&nbsp;</span>Lawvere Theories</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Categories%29" class="toclink" data-pltdoc="x">12.3<span class="hspace">&nbsp;</span>Categories</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Logic_.Category_.L_.T%29" class="toclink" data-pltdoc="x">12.3.1<span class="hspace">&nbsp;</span>Logic Category L_T</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Computation_.Category_.C_.T%29" class="toclink" data-pltdoc="x">12.3.2<span class="hspace">&nbsp;</span>Computation Category C_T</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.S.L.C_.Integration%29" class="toclink" data-pltdoc="x">12.4<span class="hspace">&nbsp;</span>SLC Integration</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Core_.S.L.C_.Implementation%29" class="toclink" data-pltdoc="x">12.4.1<span class="hspace">&nbsp;</span>Core SLC Implementation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Theory_.Analysis%29" class="toclink" data-pltdoc="x">12.5<span class="hspace">&nbsp;</span>Theory Analysis</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Parsing_and_.Formatting%29" class="toclink" data-pltdoc="x">12.6<span class="hspace">&nbsp;</span>Parsing and Formatting</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Proof_.Objects%29" class="toclink" data-pltdoc="x">12.7<span class="hspace">&nbsp;</span>Proof Objects</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Performance_and_.Benchmarking%29" class="toclink" data-pltdoc="x">12.8<span class="hspace">&nbsp;</span>Performance and Benchmarking</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Error_.Handling%29" class="toclink" data-pltdoc="x">12.9<span class="hspace">&nbsp;</span>Error Handling</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Example_.Theories%29" class="toclink" data-pltdoc="x">12.10<span class="hspace">&nbsp;</span>Example Theories</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Monoids%29" class="toclink" data-pltdoc="x">12.10.1<span class="hspace">&nbsp;</span>Monoids</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Groups%29" class="toclink" data-pltdoc="x">12.10.2<span class="hspace">&nbsp;</span>Groups</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Rings%29" class="toclink" data-pltdoc="x">12.10.3<span class="hspace">&nbsp;</span>Rings</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Interactive_.Interface%29" class="toclink" data-pltdoc="x">12.11<span class="hspace">&nbsp;</span>Interactive Interface</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Research_.Context%29" class="toptoclink" data-pltdoc="x">13<span class="hspace">&nbsp;</span>Research Context</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Related_.Work%29" class="toclink" data-pltdoc="x">13.1<span class="hspace">&nbsp;</span>Related Work</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="slc.html#%28part._.Citation%29" class="toclink" data-pltdoc="x">13.2<span class="hspace">&nbsp;</span>Citation</a></p></td></tr></table><h3 class="heading">1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction<span class="button-group"><a href="#(part._.Introduction)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>The Curry-Howard correspondence links proofs with programs and propositions with types.
Lambek embedded this insight in category theory, yielding the Curry-Howard-Lambek (CHL) correspondence.
The <span style="font-weight: bold">Structure-Logic-Computation (SLC) theorem</span> extends this foundation:</p><blockquote><p><div class="SIntrapara"><span style="font-weight: bold">SLC Theorem</span>: Every logic and every computation arise from&#8212;and are constrained by&#8212;an
underlying algebraic structure. Any Lawvere theory <span style="font-style: italic">T</span> canonically generates:
</div><div class="SIntrapara"><ul><li><p>An equational-logic category <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> capturing proofs</p></li><li><p>A rewrite category <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span> capturing computations</p></li></ul></div><div class="SIntrapara">These categories are sound and complete with respect to the models of <span style="font-style: italic">T</span>.</div></p></blockquote><h4 class="heading">1.1<tt>&nbsp;</tt><a name="(part._.Why_.C.H.L_.Alone_.Is_.Not_.Enough)"></a>Why CHL Alone Is Not Enough<span class="button-group"><a href="#(part._.Why_.C.H.L_.Alone_.Is_.Not_.Enough)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>The CHL correspondence presupposes a <span style="font-style: italic">fixed</span> calculus (typically the simply-typed &#955;-calculus)
and thus hard-wires proof theory to one particular notion of program. The SLC theorem drops one
level down: given <span style="font-style: italic">only</span> the raw algebra of the domain, it <span style="font-style: italic">derives</span> both the logic
of proofs and the machine of executions.</p><h4 class="heading">1.2<tt>&nbsp;</tt><a name="(part._.The_.S.L.C_.Triangle)"></a>The SLC Triangle<span class="button-group"><a href="#(part._.The_.S.L.C_.Triangle)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">L_T (Logic/Proofs)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9585;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9586;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">P</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">M</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9585;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&#9586;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">C_T &#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#8594; Models (Set)</span></p></td></tr><tr><td><p><span class="stt">(Computation/Rewrites)</span></p></td></tr></table></p><p><div class="SIntrapara">Where:
</div><div class="SIntrapara"><ul><li><p><span style="font-style: italic">T</span> = Lawvere theory (pure algebra: operations + equations)</p></li><li><p><span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> = Logic category (equational proofs)</p></li><li><p><span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span> = Computation category (rewrite paths)</p></li><li><p><span style="font-style: italic">P, M</span> = Canonical functors connecting computation, logic, and semantics</p></li></ul></div></p><h3 class="heading">2<tt>&nbsp;</tt><a name="(part._.Quick_.Start)"></a>Quick Start<span class="button-group"><a href="#(part._.Quick_.Start)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><h4 class="heading">2.1<tt>&nbsp;</tt><a name="(part._.Installation)"></a>Installation<span class="button-group"><a href="#(part._.Installation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>See <font class="badlink">(part "installation")</font> for detailed installation instructions.</p></blockquote></blockquote></blockquote><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"># Prerequisites: Install Racket 8.0+ from https://download.racket-lang.org/releases/</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"># Clone the repository</span></p></td></tr><tr><td><p><span class="stt">git clone https://github.com/ppcavalcante/slc.git</span></p></td></tr><tr><td><p><span class="stt">cd slc</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"># Test the installation</span></p></td></tr><tr><td><p><span class="stt">racket tests/main-tests.rkt</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"># Start the interactive REPL</span></p></td></tr><tr><td><p><span class="stt">racket slc/interactive.rkt</span></p></td></tr></table></p><h4 class="heading">2.2<tt>&nbsp;</tt><a name="(part._.Interactive_.Example)"></a>Interactive Example<span class="button-group"><a href="#(part._.Interactive_.Example)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">slc&gt; use-theory Monoid</span></p></td></tr><tr><td><p><span class="stt">Using Monoid theory</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove x * e = x</span></p></td></tr><tr><td><p><span class="stt">&#10003; Proved: (x * e) = x (method: auto)</span></p></td></tr><tr><td><p><span class="stt">Proof path:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 0: (x * e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 1: x</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">slc&gt; simulate (e * x) * e --depth=3</span></p></td></tr><tr><td><p><span class="stt">Simulating rewrites from ((e * x) * e) (depth 3):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Path 0:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 0: ((e * x) * e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 1: (x * e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 2: x</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">slc&gt; benchmark x * (y * z) = (x * y) * z</span></p></td></tr><tr><td><p><span class="stt">Benchmarking: (x * (y * z)) = ((x * y) * z) (depth 5)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">bfs: &#10003; Found path (12 ms)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">ids: &#10003; Found path (8 ms)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">confluent: &#10003; Found path (4 ms)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">auto: &#10003; Found path (4 ms)</span></p></td></tr></table></p><h3 class="heading">3<tt>&nbsp;</tt><a name="(part._.Theoretical_.Background)"></a>Theoretical Background<span class="button-group"><a href="#(part._.Theoretical_.Background)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><h4 class="heading">3.1<tt>&nbsp;</tt><a name="(part._.Lawvere_.Theories)"></a>Lawvere Theories<span class="button-group"><a href="#(part._.Lawvere_.Theories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">A <a name="(tech._lawvere._theory)"></a><span style="font-style: italic">Lawvere theory</span> <span style="font-style: italic">T</span> consists of:
</div><div class="SIntrapara"><ul><li><p>A set of <span style="font-style: italic">operations</span> with specified arities</p></li><li><p>A set of <span style="font-style: italic">equations</span> (axioms) relating terms built from these operations</p></li></ul></div></p><p><div class="SIntrapara">For example, the theory of monoids has:
</div><div class="SIntrapara"><ul><li><p>Operation: <span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span> (binary), <span class="RktSym">e</span> (nullary)</p></li><li><p>Equations: <span class="RktPn">(</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktSym">z</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">=</span></span></span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">y</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktSym">z</span><span class="RktPn">)</span>, <span class="RktSym">x</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktSym">e</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">=</span></span></span><span class="stt"> </span><span class="RktSym">x</span>, <span class="RktSym">e</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">*</span></span></span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">=</span></span></span><span class="stt"> </span><span class="RktSym">x</span></p></li></ul></div></p><h4 class="heading">3.2<tt>&nbsp;</tt><a name="(part._.The_.Logic_.Category_.L_.T)"></a>The Logic Category L_T<span class="button-group"><a href="#(part._.The_.Logic_.Category_.L_.T)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Given a Lawvere theory <span style="font-style: italic">T</span>, the logic category <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> has:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Objects</span>: Natural numbers (representing variable contexts)</p></li><li><p><span style="font-weight: bold">Morphisms</span>: Equivalence classes of term equations provable from <span style="font-style: italic">T</span></p></li><li><p><span style="font-weight: bold">Composition</span>: Categorical composition of proofs</p></li></ul></div></p><h4 class="heading">3.3<tt>&nbsp;</tt><a name="(part._.The_.Computation_.Category_.C_.T)"></a>The Computation Category C_T<span class="button-group"><a href="#(part._.The_.Computation_.Category_.C_.T)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">The computation category <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span> has:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Objects</span>: Terms built from operations in <span style="font-style: italic">T</span></p></li><li><p><span style="font-weight: bold">Morphisms</span>: Sequences of rewrite steps using equations from <span style="font-style: italic">T</span></p></li><li><p><span style="font-weight: bold">Composition</span>: Path concatenation in the rewrite graph</p></li></ul></div></p><h3 class="heading">4<tt>&nbsp;</tt><a name="(part._.Architecture_.Overview)"></a>Architecture Overview<span class="button-group"><a href="#(part._.Architecture_.Overview)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>The SLC implementation is organized into several core modules:</p><h4 class="heading">4.1<tt>&nbsp;</tt><a name="(part._.Core_.Theory_.Modules)"></a>Core Theory Modules<span class="button-group"><a href="#(part._.Core_.Theory_.Modules)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><a href="slc.html#%28mod-path._slc%2Ftheories%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/theories</span></a> - Lawvere theory definitions</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fterms%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/terms</span></a> - Term representation and operations</p></li><li><p><a href="slc.html#%28mod-path._slc%2Flt%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/lt</span></a> - Logic category <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> implementation</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fct%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/ct</span></a> - Computation category <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span> with advanced search</p></li></ul><h4 class="heading">4.2<tt>&nbsp;</tt><a name="(part._.S.L.C_.Core)"></a>SLC Core<span class="button-group"><a href="#(part._.S.L.C_.Core)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><a href="slc.html#%28mod-path._slc%2Fslc-simulator%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/slc-simulator</span></a> - Core SLC prover+simulator embodying the theorem</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fcore%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/core</span></a> - Unified module exports (main API)</p></li></ul><h4 class="heading">4.3<tt>&nbsp;</tt><a name="(part._.Implementation_.Support)"></a>Implementation Support<span class="button-group"><a href="#(part._.Implementation_.Support)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><a href="slc.html#%28mod-path._slc%2Fparser%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/parser</span></a> - Term parsing and formatting</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fproofs%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/proofs</span></a> - Proof object manipulation</p></li><li><p><a href="slc.html#%28mod-path._slc%2Ftheory-analysis%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/theory-analysis</span></a> - Theory analysis tools</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fperformance-demo%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/performance-demo</span></a> - Benchmarking tools</p></li><li><p><a href="slc.html#%28mod-path._slc%2Ferrors%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/errors</span></a> - Error handling</p></li></ul><h4 class="heading">4.4<tt>&nbsp;</tt><a name="(part._.User_.Interface)"></a>User Interface<span class="button-group"><a href="#(part._.User_.Interface)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><a href="slc.html#%28mod-path._slc%2Finteractive%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/interactive</span></a> - Interactive REPL (main entry point)</p></li></ul><h4 class="heading">4.5<tt>&nbsp;</tt><a name="(part._.Example_.Theories)"></a>Example Theories<span class="button-group"><a href="#(part._.Example_.Theories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><a href="slc.html#%28mod-path._slc%2Fexamples%2Fmonoid%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/monoid</span></a> - Monoid theory with associativity + identity</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fexamples%2Fgroup%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/group</span></a> - Group theory extending monoids with inverses</p></li><li><p><a href="slc.html#%28mod-path._slc%2Fexamples%2Fring%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/ring</span></a> - Ring theory with addition and multiplication</p></li></ul><h3 class="heading">5<tt>&nbsp;</tt><a name="(part._.The_.S.L.C_.Implementation)"></a>The SLC Implementation<span class="button-group"><a href="#(part._.The_.S.L.C_.Implementation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><h4 class="heading">5.1<tt>&nbsp;</tt><a name="(part._.Core_.S.L.C_.Function)"></a>Core SLC Function<span class="button-group"><a href="#(part._.Core_.S.L.C_.Function)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>The heart of the SLC implementation is the <span class="RktSym">prover+simulator</span> function,
which embodies the SLC theorem by proving equality in <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span> via
rewrite paths in <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span>.</p><h4 class="heading">5.2<tt>&nbsp;</tt><a name="(part._.Search_.Algorithms)"></a>Search Algorithms<span class="button-group"><a href="#(part._.Search_.Algorithms)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>The implementation includes multiple search strategies for exploring <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span>:</p><ul><li><p><span style="font-weight: bold">BFS</span>: Systematic exploration for shortest paths</p></li><li><p><span style="font-weight: bold">Iterative Deepening</span>: Memory-efficient deep searches</p></li><li><p><span style="font-weight: bold">A* Search</span>: Goal-directed search with heuristics</p></li><li><p><span style="font-weight: bold">Confluent Normalization</span>: Fast equality via normal forms</p></li><li><p><span style="font-weight: bold">Auto Method Selection</span>: Automatic algorithm choice based on problem characteristics</p></li></ul><h3 class="heading">6<tt>&nbsp;</tt><a name="(part._.Interactive_.Commands)"></a>Interactive Commands<span class="button-group"><a href="#(part._.Interactive_.Commands)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>The SLC REPL provides a comprehensive command set for exploring theories:</p><h4 class="heading">6.1<tt>&nbsp;</tt><a name="(part._.Theory_.Management)"></a>Theory Management<span class="button-group"><a href="#(part._.Theory_.Management)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><span class="RktSym">use-theory</span> <span class="sroman">&#8249;<span style="font-style: italic">NAME</span>&#8250;</span> - Load predefined theory (Monoid, Group, Ring)</p></li><li><p><span class="RktSym">define-theory</span> <span class="sroman">&#8249;<span style="font-style: italic">NAME</span>&#8250;</span> <span class="sroman">&#8249;<span style="font-style: italic">AXIOM1</span>&#8250;</span> ... - Define custom theory</p></li><li><p><span class="RktSym">analyze</span> - Analyze current theory properties</p></li></ul><h4 class="heading">6.2<tt>&nbsp;</tt><a name="(part._.Proof_and_.Computation)"></a>Proof and Computation<span class="button-group"><a href="#(part._.Proof_and_.Computation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><span class="RktSym">prove</span> <span class="sroman">&#8249;<span style="font-style: italic">LHS</span>&#8250;</span> = <span class="sroman">&#8249;<span style="font-style: italic">RHS</span>&#8250;</span> [<span class="sroman">&#8249;<span style="font-style: italic">depth</span>&#8250;</span>] [<span class="sroman">&#8249;<span style="font-style: italic">method</span>&#8250;</span>] - Prove equality using SLC</p></li><li><p><span class="RktSym">benchmark</span> <span class="sroman">&#8249;<span style="font-style: italic">LHS</span>&#8250;</span> = <span class="sroman">&#8249;<span style="font-style: italic">RHS</span>&#8250;</span> [<span class="sroman">&#8249;<span style="font-style: italic">depth</span>&#8250;</span>] - Compare search methods</p></li><li><p><span class="RktSym">normalize</span> <span class="sroman">&#8249;<span style="font-style: italic">TERM</span>&#8250;</span> - Normalize term using current theory</p></li></ul><h4 class="heading">6.3<tt>&nbsp;</tt><a name="(part._.Simulation)"></a>Simulation<span class="button-group"><a href="#(part._.Simulation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ul><li><p><span class="RktSym">simulate</span> <span class="sroman">&#8249;<span style="font-style: italic">TERM</span>&#8250;</span> [&ndash;depth=<span class="sroman">&#8249;<span style="font-style: italic">N</span>&#8250;</span>] [&ndash;states] - Explore rewrite paths from term</p></li><li><p><span class="RktSym">onestep</span> <span class="sroman">&#8249;<span style="font-style: italic">TERM</span>&#8250;</span> - Show one-step rewrites</p></li><li><p><span class="RktSym">clear-cache</span> - Clear performance caches</p></li></ul><h3 class="heading">7<tt>&nbsp;</tt><a name="(part._.Examples_and_.Applications)"></a>Examples and Applications<span class="button-group"><a href="#(part._.Examples_and_.Applications)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><h4 class="heading">7.1<tt>&nbsp;</tt><a name="(part._.Monoid_.Properties)"></a>Monoid Properties<span class="button-group"><a href="#(part._.Monoid_.Properties)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">slc&gt; use-theory Monoid</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove (x * y) * z = x * (y * z)</span></p></td></tr><tr><td><p><span class="stt">&#10003; Proved: ((x * y) * z) = (x * (y * z)) (method: auto)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove e * x = x * e</span></p></td></tr><tr><td><p><span class="stt">&#10003; Proved: (e * x) = (x * e) (method: auto)</span></p></td></tr></table></p><h4 class="heading">7.2<tt>&nbsp;</tt><a name="(part._.Group_.Inverse_.Laws)"></a>Group Inverse Laws<span class="button-group"><a href="#(part._.Group_.Inverse_.Laws)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">slc&gt; use-theory Group</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove x * ginv(x) = e</span></p></td></tr><tr><td><p><span class="stt">&#10003; Proved: (x * (ginv x)) = e (method: confluent)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">slc&gt; simulate x * ginv(x) --depth=2</span></p></td></tr><tr><td><p><span class="stt">Simulating rewrites from (x * (ginv x)) (depth 2):</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">Path 0:</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 0: (x * (ginv x))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Step 1: e</span></p></td></tr></table></p><h4 class="heading">7.3<tt>&nbsp;</tt><a name="(part._.Ring_.Distributivity)"></a>Ring Distributivity<span class="button-group"><a href="#(part._.Ring_.Distributivity)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">slc&gt; use-theory Ring</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove x * (y + z) = (x * y) + (x * z)</span></p></td></tr><tr><td><p><span class="stt">&#10003; Proved: (x * (y + z)) = ((x * y) + (x * z)) (method: auto)</span></p></td></tr></table></p><h3 class="heading">8<tt>&nbsp;</tt><a name="(part._.Applications)"></a>Applications<span class="button-group"><a href="#(part._.Applications)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>The SLC implementation enables several practical applications:</p><h4 class="heading">8.1<tt>&nbsp;</tt><a name="(part._.Security_.Analysis)"></a>Security Analysis<span class="button-group"><a href="#(part._.Security_.Analysis)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Model privilege escalation as violations of monotonicity laws in security lattices.</p><h4 class="heading">8.2<tt>&nbsp;</tt><a name="(part._.Language_.Design)"></a>Language Design<span class="button-group"><a href="#(part._.Language_.Design)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Generate both type systems (<span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span>) and interpreters (<span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span>)
from algebraic effect signatures.</p><h4 class="heading">8.3<tt>&nbsp;</tt><a name="(part._.Formal_.Verification)"></a>Formal Verification<span class="button-group"><a href="#(part._.Formal_.Verification)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Prove program equivalence in <span style="font-style: italic">L<span style="vertical-align: sub; font-size: 80%">T</span></span>, guaranteeing trace equivalence in <span style="font-style: italic">C<span style="vertical-align: sub; font-size: 80%">T</span></span>.</p><h4 class="heading">8.4<tt>&nbsp;</tt><a name="(part._.Automated_.Reasoning)"></a>Automated Reasoning<span class="button-group"><a href="#(part._.Automated_.Reasoning)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Use the prover+simulator combination for both proof search and counterexample generation.</p><h3 class="heading">9<tt>&nbsp;</tt><a name="(part._.Performance_and_.Optimization)"></a>Performance and Optimization<span class="button-group"><a href="#(part._.Performance_and_.Optimization)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>The implementation includes several performance optimizations:</p><ul><li><p><span style="font-weight: bold">Multi-level Caching</span>: Rewrite cache + normal form cache</p></li><li><p><span style="font-weight: bold">Smart Method Selection</span>: Automatic optimal algorithm choice</p></li><li><p><span style="font-weight: bold">Confluent Fast Path</span>: O(n) equality checking for confluent theories</p></li><li><p><span style="font-weight: bold">Heuristic Search</span>: Domain-aware A* heuristics</p></li></ul><h3 class="heading">10<tt>&nbsp;</tt><a name="(part._.Future_.Enhancements)"></a>Future Enhancements<span class="button-group"><a href="#(part._.Future_.Enhancements)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>Two major enhancements are planned that would significantly extend the system&rsquo;s capabilities:</p><h4 class="heading">10.1<tt>&nbsp;</tt><a name="(part._.Complete_.L_.T_~e2~86~94_.C_.T_.Bridge)"></a>Complete L_T &#8596; C_T Bridge<span class="button-group"><a href="#(part._.Complete_.L_.T_~e2~86~94_.C_.T_.Bridge)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Currently: &#9989; <span style="font-weight: bold">L_T &#8594; C_T</span> (proofs convert to rewrite paths)
Planned: &#128679; <span style="font-weight: bold">C_T &#8594; L_T</span> (rewrite paths back to formal proofs)</p><p>This would demonstrate the true bidirectional equivalence of the SLC theorem by automatically
reconstructing formal proof objects from computational rewrite paths.</p><h4 class="heading">10.2<tt>&nbsp;</tt><a name="(part._.Knuth-.Bendix_.Completion)"></a>Knuth-Bendix Completion<span class="button-group"><a href="#(part._.Knuth-.Bendix_.Completion)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Planned: &#128679; <span style="font-weight: bold">Automatic theory completion</span> for confluence</p><p><div class="SIntrapara">Transform non-confluent theories into confluent ones, enabling:
</div><div class="SIntrapara"><ul><li><p>O(n) equality checking via normalization</p></li><li><p>Unique canonical forms for all terms</p></li><li><p>Massive performance improvements for large theories</p></li></ul></div></p><h3 class="heading">11<tt>&nbsp;</tt><a name="(part._.Installation_.Guide)"></a>Installation Guide<span class="button-group"><a href="#(part._.Installation_.Guide)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><h4 class="heading">11.1<tt>&nbsp;</tt><a name="(part._.Install_.Racket)"></a>Install Racket<span class="button-group"><a href="#(part._.Install_.Racket)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>Download and install Racket 8.0 or later from:
<a href="https://download.racket-lang.org/releases/"><span class="url">https://download.racket-lang.org/releases/</span></a></p><p>Follow the installation instructions for your operating system. After installation,
ensure the <span class="RktSym">racket</span><span class="RktMeta"></span> command is available in your PATH.</p><h4 class="heading">11.2<tt>&nbsp;</tt><a name="(part._.Setup_.S.L.C)"></a>Setup SLC<span class="button-group"><a href="#(part._.Setup_.S.L.C)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><ol><li><p>Clone this repository: <span class="RktSym">git</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">clone</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;your-repo-url&gt;</span><span class="RktMeta"></span></p></li><li><p>Navigate to the directory: <span class="RktSym">cd</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">slc</span><span class="RktMeta"></span></p></li><li><p>Test the installation: <span class="RktSym">racket</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tests/main-tests.rkt</span><span class="RktMeta"></span></p></li><li><p>Start the interactive REPL: <span class="RktSym">racket</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">slc/interactive.rkt</span><span class="RktMeta"></span></p></li></ol><h4 class="heading">11.3<tt>&nbsp;</tt><a name="(part._.Quick_.Test)"></a>Quick Test<span class="button-group"><a href="#(part._.Quick_.Test)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In the SLC REPL, try:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">slc&gt; use-theory Monoid</span></p></td></tr><tr><td><p><span class="stt">slc&gt; prove x * e = x</span></p></td></tr><tr><td><p><span class="stt">slc&gt; help</span></p></td></tr></table></div></p><h4 class="heading">11.4<tt>&nbsp;</tt><a name="(part._.Troubleshooting)"></a>Troubleshooting<span class="button-group"><a href="#(part._.Troubleshooting)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><span style="font-weight: bold">Command not found</span>: Ensure Racket&rsquo;s bin directory is in your PATH.</p><p><span style="font-weight: bold">Module errors</span>: Try <span class="RktSym">raco</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">setup</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">slc</span><span class="RktMeta"></span> to rebuild compiled files. </p><h3 class="heading">12<tt>&nbsp;</tt><a name="(part._.Implementation_.Reference)"></a>Implementation Reference<span class="button-group"><a href="#(part._.Implementation_.Reference)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>This section provides detailed documentation for all modules and functions in the SLC implementation.
It serves as a reference for researchers wanting to understand the codebase or developers extending the system.</p><h4 class="heading">12.1<tt>&nbsp;</tt><a name="(part._.Core_.Interface)"></a>Core Interface<span class="button-group"><a href="#(part._.Core_.Interface)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><h5 class="heading">12.1.1<tt>&nbsp;</tt><a name="(part._.Unified_.Interface)"></a><a name="(mod-path._slc/core)"></a>Unified Interface<span class="button-group"><a href="#(part._.Unified_.Interface)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fcore%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/core</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>The core module provides unified access to all SLC functionality.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/core..rkt)._slc-prove))"></a><span title="Provided from: slc/core | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">slc-prove</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term1</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term2</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span><span class="RktOpt">[</span></td><td valign="top"><span class="RktPn">#:depth</span><span class="hspace">&nbsp;</span><span class="RktVar">depth</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">#:method</span><span class="hspace">&nbsp;</span><span class="RktVar">method</span><span class="RktOpt">]</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktSym">proof-result?</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">5</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">auto</span></td></tr></table></blockquote></div><div class="SIntrapara">Main SLC proving function. Attempts to prove equality between terms using the specified theory.
Returns a proof result if successful, <span class="RktVal">#f</span> otherwise.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/core..rkt)._slc-simulate))"></a><span title="Provided from: slc/core | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">slc-simulate</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span><span class="RktOpt">[</span><span class="RktPn">#:depth</span><span class="hspace">&nbsp;</span><span class="RktVar">depth</span><span class="RktOpt">]</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">5</span></td></tr></table></blockquote></div><div class="SIntrapara">Simulates all possible rewrite paths from the given term up to the specified depth.</div></p><h4 class="heading">12.2<tt>&nbsp;</tt><a name="(part._.Terms_and_.Theories)"></a>Terms and Theories<span class="button-group"><a href="#(part._.Terms_and_.Theories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><h5 class="heading">12.2.1<tt>&nbsp;</tt><a name="(part._.Term_.Representation)"></a><a name="(mod-path._slc/terms)"></a>Term Representation<span class="button-group"><a href="#(part._.Term_.Representation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fterms%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/terms</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/terms..rkt)._term-var-name))"></a><a name="(def._((lib._slc/terms..rkt)._make-term-var))"></a><a name="(def._((lib._slc/terms..rkt)._term-var~3f))"></a><a name="(def._((lib._slc/terms..rkt)._struct~3aterm-var))"></a><a name="(def._((lib._slc/terms..rkt)._term-var))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term-var</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-term-var</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Represents a variable in a term.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">term-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">term-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/terms..rkt)._term-const-value))"></a><a name="(def._((lib._slc/terms..rkt)._make-term-const))"></a><a name="(def._((lib._slc/terms..rkt)._term-const~3f))"></a><a name="(def._((lib._slc/terms..rkt)._struct~3aterm-const))"></a><a name="(def._((lib._slc/terms..rkt)._term-const))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term-const</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-term-const</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">number?</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Represents a constant (identity elements, literals, etc.).</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">term-const</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">term-const</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">term-const</span><span class="hspace">&nbsp;</span><span class="RktVal">"foo"</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/terms..rkt)._term-op-args))"></a><a name="(def._((lib._slc/terms..rkt)._term-op-op-sym))"></a><a name="(def._((lib._slc/terms..rkt)._make-term-op))"></a><a name="(def._((lib._slc/terms..rkt)._term-op~3f))"></a><a name="(def._((lib._slc/terms..rkt)._struct~3aterm-op))"></a><a name="(def._((lib._slc/terms..rkt)._term-op))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term-op</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">op-sym</span><span class="stt"> </span><span class="RktSym">args</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-term-op</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">op-sym</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Represents an operation applied to arguments.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">term-op</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">list</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">term-op</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">list</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term-const</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._term~3f))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term?</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">v</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">any/c</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Predicate for recognizing term structures.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._term-equal~3f))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term-equal?</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span><span class="RktVar">t2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Tests syntactic equality between terms (ignoring variable renaming).</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._free-vars))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">free-vars</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the list of free variables appearing in a term.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._substitute))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">substitute</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">substitutions</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">substitutions</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">hash/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Performs variable substitution in a term according to the given substitution map.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._rename-vars))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">rename-vars</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">renaming</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">renaming</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">hash/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Renames variables in a term according to the given renaming map.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/terms..rkt)._term-size))"></a><span title="Provided from: slc/terms | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">term-size</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the size of a term (number of nodes in its tree representation).</div></p><h5 class="heading">12.2.2<tt>&nbsp;</tt><a name="(part._.Lawvere_.Theories)"></a><a name="(mod-path._slc/theories)"></a>Lawvere Theories<span class="button-group"><a href="#(part._.Lawvere_.Theories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Ftheories%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/theories</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/theories..rkt)._lawvere-theory-axioms))"></a><a name="(def._((lib._slc/theories..rkt)._lawvere-theory-name))"></a><a name="(def._((lib._slc/theories..rkt)._make-lawvere-theory))"></a><a name="(def._((lib._slc/theories..rkt)._lawvere-theory~3f))"></a><a name="(def._((lib._slc/theories..rkt)._struct~3alawvere-theory))"></a><a name="(def._((lib._slc/theories..rkt)._lawvere-theory))"></a><span title="Provided from: slc/theories | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">lawvere-theory</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="stt"> </span><span class="RktSym">axioms</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-lawvere-theory</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">axioms</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">cons/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Represents a Lawvere theory with a name and a list of axioms (equations).
Each axiom is a pair <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">cons</span></span></span><span class="stt"> </span><span class="RktSym">lhs</span><span class="stt"> </span><span class="RktSym">rhs</span><span class="RktPn">)</span> representing the equation <span class="RktSym">lhs</span><span class="stt"> </span><span class="RktSym"><span class="badlink"><span class="RktValLink">=</span></span></span><span class="stt"> </span><span class="RktSym">rhs</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theories..rkt)._make-theory))"></a><span title="Provided from: slc/theories | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">make-theory</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">name</span><span class="hspace">&nbsp;</span><span class="RktVar">axiom-list</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">name</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">axiom-list</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">cons/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Constructs a new Lawvere theory with the given name and axioms.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theories..rkt)._theory-axioms))"></a><span title="Provided from: slc/theories | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">theory-axioms</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">cons/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the list of axioms for a theory.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theories..rkt)._theory-name))"></a><span title="Provided from: slc/theories | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">theory-name</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the name of a theory.</div></p><h4 class="heading">12.3<tt>&nbsp;</tt><a name="(part._.Categories)"></a>Categories<span class="button-group"><a href="#(part._.Categories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><h5 class="heading">12.3.1<tt>&nbsp;</tt><a name="(part._.Logic_.Category_.L_.T)"></a><a name="(mod-path._slc/lt)"></a>Logic Category L_T<span class="button-group"><a href="#(part._.Logic_.Category_.L_.T)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Flt%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/lt</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>The logic category captures equational proofs as morphisms.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/lt..rkt)._lt-prove-equality))"></a><span title="Provided from: slc/lt | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">lt-prove-equality</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term1</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term2</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Attempts to prove that two terms are equal in the logic category L_T.
Returns a proof object if successful, <span class="RktVal">#f</span> otherwise.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/lt..rkt)._lt-build-proof))"></a><span title="Provided from: slc/lt | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">lt-build-proof</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">proof-step?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Builds a step-by-step proof showing how to derive the equality.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/lt..rkt)._proof-object-valid~3f))"></a><a name="(def._((lib._slc/lt..rkt)._proof-object-steps))"></a><a name="(def._((lib._slc/lt..rkt)._make-proof-object))"></a><a name="(def._((lib._slc/lt..rkt)._proof-object~3f))"></a><a name="(def._((lib._slc/lt..rkt)._struct~3aproof-object))"></a><a name="(def._((lib._slc/lt..rkt)._proof-object))"></a><span title="Provided from: slc/lt | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">proof-object</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">steps</span><span class="stt"> </span><span class="RktSym">valid?</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-proof-object</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">steps</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">proof-step?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">valid?</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Represents a formal proof in L_T with a sequence of proof steps.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/lt..rkt)._proof-step-conclusion))"></a><a name="(def._((lib._slc/lt..rkt)._proof-step-premises))"></a><a name="(def._((lib._slc/lt..rkt)._proof-step-rule))"></a><a name="(def._((lib._slc/lt..rkt)._make-proof-step))"></a><a name="(def._((lib._slc/lt..rkt)._proof-step~3f))"></a><a name="(def._((lib._slc/lt..rkt)._struct~3aproof-step))"></a><a name="(def._((lib._slc/lt..rkt)._proof-step))"></a><span title="Provided from: slc/lt | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">proof-step</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rule</span><span class="stt"> </span><span class="RktSym">premises</span><span class="stt"> </span><span class="RktSym">conclusion</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-proof-step</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">rule</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">premises</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">conclusion</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Represents a single step in a proof, including the rule applied and the terms involved.</div></p><h5 class="heading">12.3.2<tt>&nbsp;</tt><a name="(part._.Computation_.Category_.C_.T)"></a><a name="(mod-path._slc/ct)"></a>Computation Category C_T<span class="button-group"><a href="#(part._.Computation_.Category_.C_.T)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fct%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/ct</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>The computation category captures rewrite paths as morphisms.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/ct..rkt)._ct-find-path))"></a><span title="Provided from: slc/ct | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">ct-find-path</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">start-term</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">end-term</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span><span class="RktOpt">[</span></td><td valign="top"><span class="RktPn">#:method</span><span class="hspace">&nbsp;</span><span class="RktVar">method</span><span class="RktOpt">]</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">start-term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">end-term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">auto</span></td></tr></table></blockquote></div><div class="SIntrapara">Finds a rewrite path from start-term to end-term in the computation category C_T.
Methods include <span class="RktVal">'</span><span class="RktVal">bfs</span>, <span class="RktVal">'</span><span class="RktVal">ids</span>, <span class="RktVal">'</span><span class="RktVal">astar</span>, <span class="RktVal">'</span><span class="RktVal">confluent</span>, and <span class="RktVal">'</span><span class="RktVal">auto</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/ct..rkt)._one-step-rewrites))"></a><span title="Provided from: slc/ct | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">one-step-rewrites</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns all terms reachable from the given term in exactly one rewrite step.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/ct..rkt)._normalize-term))"></a><span title="Provided from: slc/ct | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">normalize-term</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Attempts to normalize a term to its canonical form (if the theory is confluent).</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/ct..rkt)._ct-reachable-terms))"></a><span title="Provided from: slc/ct | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">ct-reachable-terms</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span><span class="RktVar">max-depth</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set/c</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the set of all terms reachable from the given term within max-depth steps.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/ct..rkt)._smart-search))"></a><span title="Provided from: slc/ct | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">smart-search</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">start-term</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">end-term</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">#:method</span><span class="hspace">&nbsp;</span><span class="RktVar">method</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktSym">search-result?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">start-term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">end-term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Advanced search with multiple strategies and performance optimizations.</div></p><h4 class="heading">12.4<tt>&nbsp;</tt><a name="(part._.S.L.C_.Integration)"></a>SLC Integration<span class="button-group"><a href="#(part._.S.L.C_.Integration)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><h5 class="heading">12.4.1<tt>&nbsp;</tt><a name="(part._.Core_.S.L.C_.Implementation)"></a><a name="(mod-path._slc/slc-simulator)"></a>Core SLC Implementation<span class="button-group"><a href="#(part._.Core_.S.L.C_.Implementation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fslc-simulator%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/slc-simulator</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>This module embodies the SLC theorem by integrating logic and computation categories.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/slc-simulator..rkt)._prover+simulator))"></a><span title="Provided from: slc/slc-simulator | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">prover+simulator</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term1</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term2</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span><span class="RktOpt">[</span></td><td valign="top"><span class="RktPn">#:method</span><span class="hspace">&nbsp;</span><span class="RktVar">method</span><span class="RktOpt">]</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktSym">slc-result?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">auto</span></td></tr></table></blockquote></div><div class="SIntrapara">Core SLC function: proves equality in L_T by finding rewrite paths in C_T.
This function embodies the central insight of the SLC theorem.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/slc-simulator..rkt)._simulate-rewrites))"></a><span title="Provided from: slc/slc-simulator | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">simulate-rewrites</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span><span class="RktVar">max-depth</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">simulation-result?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Simulates all possible rewrite sequences from a given term, showing the computation space.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/slc-simulator..rkt)._reachable-terms-by-depth))"></a><span title="Provided from: slc/slc-simulator | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">reachable-terms-by-depth</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set/c</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Returns a list where each element is the set of terms reachable at that depth level.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result-time-ms))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result-proof))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result-path))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result-method))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result-proved~3f))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._make-slc-result))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result~3f))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._struct~3aslc-result))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._slc-result))"></a><span title="Provided from: slc/slc-simulator | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">slc-result</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">proved?</span><span class="stt"> </span><span class="RktSym">method</span><span class="stt"> </span><span class="RktSym">path</span><span class="stt"> </span><span class="RktSym">proof</span><span class="stt"> </span><span class="RktSym">time-ms</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-slc-result</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">proved?</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">path</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">proof</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">time-ms</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Result structure for SLC proving attempts, containing both logical and computational evidence.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/slc-simulator..rkt)._simulation-result-total-states))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._simulation-result-states-by-depth))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._simulation-result-paths))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._make-simulation-result))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._simulation-result~3f))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._struct~3asimulation-result))"></a><a name="(def._((lib._slc/slc-simulator..rkt)._simulation-result))"></a><span title="Provided from: slc/slc-simulator | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">simulation-result</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">paths</span><span class="stt"> </span><span class="RktSym">states-by-depth</span><span class="stt"> </span><span class="RktSym">total-states</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-simulation-result</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">paths</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">states-by-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set/c</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">total-states</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Result structure for simulation runs, showing the exploration of the computation space.</div></p><h4 class="heading">12.5<tt>&nbsp;</tt><a name="(part._.Theory_.Analysis)"></a><a name="(mod-path._slc/theory-analysis)"></a>Theory Analysis<span class="button-group"><a href="#(part._.Theory_.Analysis)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Ftheory-analysis%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/theory-analysis</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>Tools for analyzing properties and structure of Lawvere theories.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theory-analysis..rkt)._analyze-theory))"></a><span title="Provided from: slc/theory-analysis | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">analyze-theory</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">theory-analysis?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Performs comprehensive analysis of a theory&rsquo;s properties.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/theory-analysis..rkt)._check-confluence))"></a><span title="Provided from: slc/theory-analysis | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">check-confluence</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span><span class="RktOpt">[</span></td><td valign="top"><span class="RktPn">#:sample-size</span><span class="hspace">&nbsp;</span><span class="RktVar">size</span><span class="RktOpt">]</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktSym">confluence-result?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">size</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">100</span></td></tr></table></blockquote></div><div class="SIntrapara">Checks if a theory appears to be confluent by testing sample terms.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theory-analysis..rkt)._estimate-complexity))"></a><span title="Provided from: slc/theory-analysis | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">estimate-complexity</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">complexity-estimate?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Estimates the computational complexity characteristics of the theory.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/theory-analysis..rkt)._suggest-optimizations))"></a><span title="Provided from: slc/theory-analysis | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">suggest-optimizations</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">optimization-suggestion?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Suggests optimizations based on theory structure analysis.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><span class="nobreak"><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis-optimizations))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis-complexity))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis-confluence))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis-properties))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._make-theory-analysis))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis~3f))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._struct~3atheory-analysis))"></a><a name="(def._((lib._slc/theory-analysis..rkt)._theory-analysis))"></a><span title="Provided from: slc/theory-analysis | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">theory-analysis</span></span></span></span></td><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span></td><td><span class="nobreak"><span class="RktSym">properties</span></span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">confluence</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">complexity</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktSym">optimizations</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-theory-analysis</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">properties</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">confluence</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">confluence-result?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">complexity</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">complexity-estimate?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">optimizations</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">optimization-suggestion?</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Comprehensive analysis result for a theory.</div></p><h4 class="heading">12.6<tt>&nbsp;</tt><a name="(part._.Parsing_and_.Formatting)"></a><a name="(mod-path._slc/parser)"></a>Parsing and Formatting<span class="button-group"><a href="#(part._.Parsing_and_.Formatting)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fparser%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/parser</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/parser..rkt)._parse-term))"></a><span title="Provided from: slc/parser | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">parse-term</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">input</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="hspace">&nbsp;</span><span class="RktSym">parse-error?</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">input</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Parses a string representation into a term structure.
Supports both infix and prefix notation.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">parse-term</span><span class="hspace">&nbsp;</span><span class="RktVal">"x * y"</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">parse-term</span><span class="hspace">&nbsp;</span><span class="RktVal">"(* x y)"</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">parse-term</span><span class="hspace">&nbsp;</span><span class="RktVal">"x * (y + z)"</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/parser..rkt)._parse-equation))"></a><span title="Provided from: slc/parser | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">parse-equation</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">input</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">cons/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="hspace">&nbsp;</span><span class="RktSym">term?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">parse-error?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">input</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Parses a string equation into a pair of terms.</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">parse-equation</span><span class="hspace">&nbsp;</span><span class="RktVal">"x * e = x"</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">parse-equation</span><span class="hspace">&nbsp;</span><span class="RktVal">"(x * y) * z = x * (y * z)"</span><span class="RktPn">)</span></td></tr></table></blockquote><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/parser..rkt)._format-term))"></a><span title="Provided from: slc/parser | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">format-term</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktOpt">[</span><span class="RktPn">#:style</span><span class="hspace">&nbsp;</span><span class="RktVar">style</span><span class="RktOpt">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">style</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">infix</span></td></tr></table></blockquote></div><div class="SIntrapara">Formats a term as a string. Styles include <span class="RktVal">'</span><span class="RktVal">infix</span>, <span class="RktVal">'</span><span class="RktVal">prefix</span>, and <span class="RktVal">'</span><span class="RktVal">pretty</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/parser..rkt)._format-equation))"></a><span title="Provided from: slc/parser | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">format-equation</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">lhs</span><span class="hspace">&nbsp;</span><span class="RktVar">rhs</span><span class="hspace">&nbsp;</span><span class="RktOpt">[</span><span class="RktPn">#:style</span><span class="hspace">&nbsp;</span><span class="RktVar">style</span><span class="RktOpt">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">lhs</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">rhs</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">style</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">infix</span></td></tr></table></blockquote></div><div class="SIntrapara">Formats an equation as a string.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/parser..rkt)._parse-error-position))"></a><a name="(def._((lib._slc/parser..rkt)._parse-error-message))"></a><a name="(def._((lib._slc/parser..rkt)._make-parse-error))"></a><a name="(def._((lib._slc/parser..rkt)._parse-error~3f))"></a><a name="(def._((lib._slc/parser..rkt)._struct~3aparse-error))"></a><a name="(def._((lib._slc/parser..rkt)._parse-error))"></a><span title="Provided from: slc/parser | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">parse-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">message</span><span class="stt"> </span><span class="RktSym">position</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-parse-error</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">message</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">position</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Error structure for parsing failures.</div></p><h4 class="heading">12.7<tt>&nbsp;</tt><a name="(part._.Proof_.Objects)"></a><a name="(mod-path._slc/proofs)"></a>Proof Objects<span class="button-group"><a href="#(part._.Proof_.Objects)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fproofs%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/proofs</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>Structured representation and manipulation of proofs.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/proofs..rkt)._make-proof))"></a><span title="Provided from: slc/proofs | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">make-proof</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">steps</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">steps</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">proof-step?</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Constructs a proof object from a sequence of steps.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/proofs..rkt)._proof-valid~3f))"></a><span title="Provided from: slc/proofs | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">proof-valid?</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">proof</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proof</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Checks if a proof is valid according to the given theory.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/proofs..rkt)._proof-length))"></a><span title="Provided from: slc/proofs | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">proof-length</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">proof</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proof</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></td></tr></table></blockquote></div><div class="SIntrapara">Returns the number of steps in a proof.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/proofs..rkt)._compose-proofs))"></a><span title="Provided from: slc/proofs | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">compose-proofs</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">proof1</span><span class="hspace">&nbsp;</span><span class="RktVar">proof2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proof1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proof2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></td></tr></table></blockquote></div><div class="SIntrapara">Composes two proofs into a single proof (categorical composition).</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/proofs..rkt)._format-proof))"></a><span title="Provided from: slc/proofs | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">format-proof</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">proof</span><span class="hspace">&nbsp;</span><span class="RktOpt">[</span><span class="RktPn">#:style</span><span class="hspace">&nbsp;</span><span class="RktVar">style</span><span class="RktOpt">]</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">proof</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">proof-object?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">style</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">detailed</span></td></tr></table></blockquote></div><div class="SIntrapara">Formats a proof for display. Styles include <span class="RktVal">'</span><span class="RktVal">detailed</span>, <span class="RktVal">'</span><span class="RktVal">compact</span>, and <span class="RktVal">'</span><span class="RktVal">latex</span>.</div></p><h4 class="heading">12.8<tt>&nbsp;</tt><a name="(part._.Performance_and_.Benchmarking)"></a><a name="(mod-path._slc/performance-demo)"></a>Performance and Benchmarking<span class="button-group"><a href="#(part._.Performance_and_.Benchmarking)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fperformance-demo%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/performance-demo</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>Tools for performance analysis and benchmarking.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><table cellspacing="0" cellpadding="0" class="prototype RForeground"><tr><td valign="top"><span class="RktPn">(</span><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-methods))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">benchmark-methods</span></span></span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term1</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">term2</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">theory</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td></tr><tr><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktVar">max-depth</span><span class="RktPn">)</span></td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top">&rarr;</td><td valign="top"><span class="hspace">&nbsp;</span></td><td valign="top"><span class="RktSym">benchmark-result?</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Compares the performance of different search methods on the same problem.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/performance-demo..rkt)._performance-profile))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">performance-profile</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span><span class="RktVar">max-depth</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">profile-result?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">term</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">max-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Profiles the performance characteristics of operations on a specific term.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/performance-demo..rkt)._clear-all-caches!))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">clear-all-caches!</span></span></span><span class="RktPn"></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">void?</span></span></span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Clears all internal performance caches to ensure clean benchmarking.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/performance-demo..rkt)._get-cache-statistics))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">get-cache-statistics</span></span></span><span class="RktPn"></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">cache-stats?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Returns statistics about cache usage and hit rates.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-result-total-time-ms))"></a><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-result-best-method))"></a><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-result-methods))"></a><a name="(def._((lib._slc/performance-demo..rkt)._make-benchmark-result))"></a><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-result~3f))"></a><a name="(def._((lib._slc/performance-demo..rkt)._struct~3abenchmark-result))"></a><a name="(def._((lib._slc/performance-demo..rkt)._benchmark-result))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">benchmark-result</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">methods</span><span class="stt"> </span><span class="RktSym">best-method</span><span class="stt"> </span><span class="RktSym">total-time-ms</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-benchmark-result</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">methods</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">listof</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">method-result?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">best-method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">total-time-ms</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Result of comparing multiple methods on the same problem.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/performance-demo..rkt)._method-result-path-length))"></a><a name="(def._((lib._slc/performance-demo..rkt)._method-result-time-ms))"></a><a name="(def._((lib._slc/performance-demo..rkt)._method-result-success~3f))"></a><a name="(def._((lib._slc/performance-demo..rkt)._method-result-method))"></a><a name="(def._((lib._slc/performance-demo..rkt)._make-method-result))"></a><a name="(def._((lib._slc/performance-demo..rkt)._method-result~3f))"></a><a name="(def._((lib._slc/performance-demo..rkt)._struct~3amethod-result))"></a><a name="(def._((lib._slc/performance-demo..rkt)._method-result))"></a><span title="Provided from: slc/performance-demo | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">method-result</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">method</span><span class="stt"> </span><span class="RktSym">success?</span><span class="stt"> </span><span class="RktSym">time-ms</span><span class="stt"> </span><span class="RktSym">path-length</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-method-result</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">success?</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">time-ms</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">path-length</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Result for a single method in a benchmark comparison.</div></p><h4 class="heading">12.9<tt>&nbsp;</tt><a name="(part._.Error_.Handling)"></a><a name="(mod-path._slc/errors)"></a>Error Handling<span class="button-group"><a href="#(part._.Error_.Handling)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Ferrors%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/errors</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>Structured error handling for the SLC system.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/errors..rkt)._slc-error-context))"></a><a name="(def._((lib._slc/errors..rkt)._slc-error-message))"></a><a name="(def._((lib._slc/errors..rkt)._slc-error-type))"></a><a name="(def._((lib._slc/errors..rkt)._make-slc-error))"></a><a name="(def._((lib._slc/errors..rkt)._slc-error~3f))"></a><a name="(def._((lib._slc/errors..rkt)._struct~3aslc-error))"></a><a name="(def._((lib._slc/errors..rkt)._slc-error))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">slc-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type</span><span class="stt"> </span><span class="RktSym">message</span><span class="stt"> </span><span class="RktSym">context</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-slc-error</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">type</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">message</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">context</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">any/c</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Base error structure for SLC-specific errors.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/errors..rkt)._parse-error-position))"></a><a name="(def._((lib._slc/errors..rkt)._make-parse-error))"></a><a name="(def._((lib._slc/errors..rkt)._parse-error~3f))"></a><a name="(def._((lib._slc/errors..rkt)._struct~3aparse-error))"></a><a name="(def._((lib._slc/errors..rkt)._parse-error))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">parse-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">slc-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">position</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-parse-error</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">position</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Error in parsing terms or equations.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/errors..rkt)._theory-error-theory))"></a><a name="(def._((lib._slc/errors..rkt)._make-theory-error))"></a><a name="(def._((lib._slc/errors..rkt)._theory-error~3f))"></a><a name="(def._((lib._slc/errors..rkt)._struct~3atheory-error))"></a><a name="(def._((lib._slc/errors..rkt)._theory-error))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">theory-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">slc-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">theory</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-theory-error</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></td></tr></table></blockquote></div><div class="SIntrapara">Error related to theory operations.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/errors..rkt)._proof-error-step-number))"></a><a name="(def._((lib._slc/errors..rkt)._make-proof-error))"></a><a name="(def._((lib._slc/errors..rkt)._proof-error~3f))"></a><a name="(def._((lib._slc/errors..rkt)._struct~3aproof-error))"></a><a name="(def._((lib._slc/errors..rkt)._proof-error))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">proof-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">slc-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">step-number</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-proof-error</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">step-number</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Error in proof construction or validation.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/errors..rkt)._slc-error~3f))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">slc-error?</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">v</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">any/c</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Predicate for recognizing SLC errors.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/errors..rkt)._format-error))"></a><span title="Provided from: slc/errors | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">format-error</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">error</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">error</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">slc-error?</span></td></tr></table></blockquote></div><div class="SIntrapara">Formats an error for display to users.</div></p><h4 class="heading">12.10<tt>&nbsp;</tt><a name="(part._.Example_.Theories)"></a>Example Theories<span class="button-group"><a href="#(part._.Example_.Theories)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><h5 class="heading">12.10.1<tt>&nbsp;</tt><a name="(part._.Monoids)"></a><a name="(mod-path._slc/examples/monoid)"></a>Monoids<span class="button-group"><a href="#(part._.Monoids)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left" colspan="2"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fexamples%2Fmonoid%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/monoid</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/monoid..rkt)._.T_.Monoid))"></a><span title="Provided from: slc/examples/monoid"><span class="RktSym"><span class="RktSymDef RktSym">T_Monoid</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Complete monoid theory with associativity and identity laws.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/monoid..rkt)._mvar))"></a><span title="Provided from: slc/examples/monoid"><span class="RktSym"><span class="RktSymDef RktSym">mvar</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-var?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">name</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">symbol?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Convenience constructor for monoid variables.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/monoid..rkt)._me))"></a><span title="Provided from: slc/examples/monoid"><span class="RktSym"><span class="RktSymDef RktSym">me</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term-const?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">The monoid identity element <span class="RktSym">e</span>.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/monoid..rkt)._m*))"></a><span title="Provided from: slc/examples/monoid"><span class="RktSym"><span class="RktSymDef RktSym">m*</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span><span class="RktVar">t2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Monoid multiplication operation.</div></p><h5 class="heading">12.10.2<tt>&nbsp;</tt><a name="(part._.Groups)"></a><a name="(mod-path._slc/examples/group)"></a>Groups<span class="button-group"><a href="#(part._.Groups)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left" colspan="2"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fexamples%2Fgroup%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/group</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/group..rkt)._.T_.Group))"></a><span title="Provided from: slc/examples/group"><span class="RktSym"><span class="RktSymDef RktSym">T_Group</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Complete group theory extending monoids with inverse operations.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/group..rkt)._ginv))"></a><span title="Provided from: slc/examples/group"><span class="RktSym"><span class="RktSymDef RktSym">ginv</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Group inverse operation.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/group..rkt)._ge))"></a><span title="Provided from: slc/examples/group"><span class="RktSym"><span class="RktSymDef RktSym">ge</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term-const?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Group identity element.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/group..rkt)._g*))"></a><span title="Provided from: slc/examples/group"><span class="RktSym"><span class="RktSymDef RktSym">g*</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span><span class="RktVar">t2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Group multiplication operation.</div></p><h5 class="heading">12.10.3<tt>&nbsp;</tt><a name="(part._.Rings)"></a><a name="(mod-path._slc/examples/ring)"></a>Rings<span class="button-group"><a href="#(part._.Rings)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left" colspan="2"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Fexamples%2Fring%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/examples/ring</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/ring..rkt)._.T_.Ring))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">T_Ring</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Complete ring theory with addition, multiplication, and distributivity laws.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/ring..rkt)._r+))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">r+</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span><span class="RktVar">t2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Ring addition operation.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/ring..rkt)._r*))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">r*</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span><span class="RktVar">t2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t1</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t2</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Ring multiplication operation.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/ring..rkt)._rzero))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">rzero</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term-const?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Additive identity (zero) in the ring.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>value</p></div></div><p class="RForeground"><a name="(def._((lib._slc/examples/ring..rkt)._rone))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">rone</span></span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term-const?</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Multiplicative identity (one) in the ring.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/examples/ring..rkt)._rneg))"></a><span title="Provided from: slc/examples/ring"><span class="RktSym"><span class="RktSymDef RktSym">rneg</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">term-op?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">term?</span></td></tr></table></blockquote></div><div class="SIntrapara">Additive inverse (negation) operation.</div></p><h4 class="heading">12.11<tt>&nbsp;</tt><a name="(part._.Interactive_.Interface)"></a><a name="(mod-path._slc/interactive)"></a>Interactive Interface<span class="button-group"><a href="#(part._.Interactive_.Interface)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><table cellspacing="0" cellpadding="0" class="defmodule"><tr><td align="left"><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><a href="slc.html#%28mod-path._slc%2Finteractive%29" class="RktModLink" data-pltdoc="x"><span class="RktSym">slc/interactive</span></a><span class="RktPn">)</span></td><td align="right"><span class="RpackageSpec"><span class="Smaller">&nbsp;package:</span> <a href="https://pkgs.racket-lang.org/package/slc" title="Install this package using `raco pkg install slc`"><span class="stt">slc</span></a></span></td></tr></table></p><p>The interactive REPL provides a command-line interface for exploring SLC implementations.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/interactive..rkt)._start-slc-repl))"></a><span title="Provided from: slc/interactive | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">start-slc-repl</span></span></span><span class="RktPn"></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">void?</span></span></span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Starts the SLC interactive REPL with full command support.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><a name="(def._((lib._slc/interactive..rkt)._process-command))"></a><span title="Provided from: slc/interactive | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">process-command</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">input</span><span class="hspace">&nbsp;</span><span class="RktVar">state</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">repl-state?</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">input</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">string?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">state</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">repl-state?</span></td></tr></table></blockquote></div><div class="SIntrapara">Processes a single command and returns the updated REPL state.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>struct</p></div></div><table cellspacing="0" cellpadding="0" class="RForeground"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">struct</span></span></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(def._((lib._slc/interactive..rkt)._repl-state-default-depth))"></a><a name="(def._((lib._slc/interactive..rkt)._repl-state-cache-enabled~3f))"></a><a name="(def._((lib._slc/interactive..rkt)._repl-state-current-theory))"></a><a name="(def._((lib._slc/interactive..rkt)._make-repl-state))"></a><a name="(def._((lib._slc/interactive..rkt)._repl-state~3f))"></a><a name="(def._((lib._slc/interactive..rkt)._struct~3arepl-state))"></a><a name="(def._((lib._slc/interactive..rkt)._repl-state))"></a><span title="Provided from: slc/interactive | Package: slc"><span class="RktSym"><span class="RktSymDef RktSym">repl-state</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">current-theory</span><span class="stt"> </span><span class="RktSym">cache-enabled?</span><span class="stt"> </span><span class="RktSym">default-depth</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym">make-repl-state</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">current-theory</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">or/c</span></span></span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="hspace">&nbsp;</span><span class="RktSym">lawvere-theory?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">cache-enabled?</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">boolean?</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">default-depth</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">exact-nonnegative-integer?</span></span></span></td></tr></table></blockquote></div><div class="SIntrapara">Maintains the state of the interactive REPL session.</div></p><p>The REPL supports the following command categories:</p><ul><li><p><span style="font-weight: bold">Theory Management</span>: <span class="RktSym">use-theory</span>, <span class="RktSym">define-theory</span>, <span class="RktSym">analyze</span></p></li><li><p><span style="font-weight: bold">Proof Commands</span>: <span class="RktSym">prove</span>, <span class="RktSym">benchmark</span>, <span class="RktSym">normalize</span></p></li><li><p><span style="font-weight: bold">Simulation</span>: <span class="RktSym">simulate</span>, <span class="RktSym">onestep</span>, <span class="RktSym">clear-cache</span></p></li><li><p><span style="font-weight: bold">Utilities</span>: <span class="RktSym">help</span>, <span class="RktSym"><span class="badlink"><span class="RktValLink">exit</span></span></span></p></li></ul><h3 class="heading">13<tt>&nbsp;</tt><a name="(part._.Research_.Context)"></a>Research Context<span class="button-group"><a href="#(part._.Research_.Context)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h3><p>This implementation accompanies the paper "Extending Curry-Howard-Lambek: The Structure-Logic-Computation (SLC) Theorem" which provides the complete mathematical development of the SLC theorem, rigorous proofs, and detailed examples.</p><h4 class="heading">13.1<tt>&nbsp;</tt><a name="(part._.Related_.Work)"></a>Related Work<span class="button-group"><a href="#(part._.Related_.Work)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">The SLC theorem builds on:
</div><div class="SIntrapara"><ul><li><p>Curry-Howard correspondence (Howard, 1980)</p></li><li><p>Lambek&rsquo;s categorical logic (Lambek, 1969)</p></li><li><p>Lawvere theories (Lawvere, 1963)</p></li><li><p>Term rewriting systems (Baader &amp; Nipkow, 1998)</p></li></ul></div></p><h4 class="heading">13.2<tt>&nbsp;</tt><a name="(part._.Citation)"></a>Citation<span class="button-group"><a href="#(part._.Citation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p>If you use this implementation in your research, please cite both the software and the accompanying paper. </p></div></div><div id="contextindicator">&nbsp;</div></body></html>